<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Introducci칩n a Data Visualization - DataViz-Storytelling</title>

  <!-- styles: usamos CDN para que funcione en htmlpreview/jsDelivr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/angra8410/all-my-learnings@main/DataViz-Storytelling/examples/styles.css">

  <!-- Chart & Plotly CDN (se intenta cargar aqu칤; fallback din치mico si no est치 disponible) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist@2.26.0/plotly.min.js"></script>

  <style>
    .chart-container{ position: relative; height: 420px; margin-bottom: 12px; }
    .chart-canvas{ width:100% !important; height:100% !important; display:block; }
    .hidden{ display:none; }
    #fallback-toast { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .file-upload-area.dragover { outline: 3px dashed rgba(102,126,234,0.6); background: rgba(102,126,234,0.03); }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>游늵 M칩dulo 01: Introducci칩n a Data Visualization</h1>
      <p>Ejercicio Interactivo - DataViz-Storytelling</p>
    </div>

    <div class="content">
      <div class="alert alert-info">
        <strong>Instrucciones:</strong> Carga un CSV, configura el gr치fico y responde el cuestionario.
      </div>

      <!-- Paso 1: Cargar datos -->
      <div class="section">
        <h2>游늬 Paso 1: Cargar Datos</h2>
        <div class="form-group">
          <label>Cargar archivo CSV:</label>
          <div class="file-upload-area" onclick="document.getElementById('fileInput').click()" style="border:2px dashed #9aa;padding:24px;text-align:center;cursor:pointer;">
            <input type="file" id="fileInput" accept=".csv" onchange="loadCSV(event)">
            <p>游늭 Click aqu칤 para seleccionar un archivo CSV</p>
            <p style="font-size: 0.9em; opacity: 0.7;">O usa los archivos de ejemplo en /examples/</p>
          </div>
        </div>
        <div class="form-group">
          <label>O pega datos CSV:</label>
          <textarea id="csvTextInput" placeholder="Mes,Producto,Ventas&#10;Enero,A,150&#10;Febrero,A,180" rows="6" style="width:100%"></textarea>
          <button class="btn btn-secondary" onclick="parseManualCSV()">Cargar datos pegados</button>
        </div>

        <div id="dataPreview" class="hidden">
          <h3>Vista previa de datos:</h3>
          <div style="overflow-x: auto;">
            <table class="data-table" id="dataTable"></table>
          </div>
          <p><strong>Filas cargadas:</strong> <span id="rowCount">0</span></p>
        </div>
      </div>

      <!-- Paso 2: Configurar gr치fico -->
      <div class="section">
        <h2>丘뙖잺 Paso 2: Configurar Gr치fico</h2>
        <div class="form-group">
          <label for="chartType">Tipo de gr치fico:</label>
          <select id="chartType">
            <option value="bar">Barras</option>
            <option value="line">L칤neas</option>
            <option value="scatter">Dispersi칩n (Scatter)</option>
            <option value="pie">Circular (Pie)</option>
            <option value="doughnut">Dona (Doughnut)</option>
          </select>
        </div>

        <div class="form-group">
          <label for="xAxis">Eje X (etiquetas):</label>
          <select id="xAxis"><option value="">Selecciona columna...</option></select>
        </div>
        <div class="form-group">
          <label for="yAxis">Eje Y (valores):</label>
          <select id="yAxis"><option value="">Selecciona columna...</option></select>
        </div>
        <div class="form-group">
          <label for="groupBy">Agrupar por (opcional):</label>
          <select id="groupBy"><option value="">Sin agrupaci칩n</option></select>
        </div>
        <div class="form-group">
          <label for="aggregation">Operaci칩n de agregaci칩n:</label>
          <select id="aggregation">
            <option value="sum">Suma</option><option value="avg">Promedio</option>
            <option value="count">Conteo</option><option value="max">M치ximo</option>
            <option value="min">M칤nimo</option>
          </select>
        </div>
        <div class="form-group">
          <label for="chartTitle">T칤tulo del gr치fico:</label>
          <input type="text" id="chartTitle" placeholder="Mi Gr치fico de Datos">
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" onclick="renderChart()">Generar Gr치fico</button>
          <button class="btn btn-secondary" onclick="clearChart()">Limpiar</button>
        </div>
      </div>

      <!-- Paso 3: Visualizaci칩n -->
      <div class="section">
        <h2>游늵 Paso 3: Visualizaci칩n</h2>
        <div class="chart-container">
          <canvas id="myChart" class="chart-canvas"></canvas>
        </div>
        <div class="btn-group">
          <button class="btn btn-success" onclick="downloadChart()">Descargar Gr치fico PNG</button>
          <button class="btn btn-secondary" onclick="downloadProcessedData()">Descargar Datos Procesados CSV</button>
        </div>
      </div>

      <!-- Paso 4 & 5 omitted for brevity in page view (kept in scripts) -->
    </div>
  </div>

  <!-- utils.js desde jsDelivr (apunta a tu repo/branch) -->
  <script src="https://cdn.jsdelivr.net/gh/angra8410/all-my-learnings@main/DataViz-Storytelling/examples/utils.js"></script>

  <!-- FALLBACKS: parseCSV, showNotification, storage, CSV utils, safe group/aggregate -->
  <script>
  (function(){
    // parseCSV fallback
    if (typeof parseCSV !== 'function') {
      window.parseCSV = function(text) {
        if (!text) return [];
        const sample = String(text).slice(0, 2000);
        const counts = { ',': (sample.match(/,/g)||[]).length, ';': (sample.match(/;/g)||[]).length, '\t': (sample.match(/\t/g)||[]).length };
        let delim = ',';
        if (counts[';'] > counts[','] && counts[';'] >= counts['\t']) delim = ';';
        else if (counts['\t'] > counts[','] && counts['\t'] >= counts[';']) delim = '\t';
        const lines = String(text).trim().split(/\r?\n/).filter(l => l.trim().length>0);
        if (lines.length === 0) return [];
        const headers = lines.shift().split(delim).map(h=>h.trim());
        return lines.map(l=>{
          const cols = l.split(delim);
          const obj = {};
          for (let i=0;i<headers.length;i++) obj[headers[i]] = (cols[i]||'').trim();
          return obj;
        });
      };
      console.info('[fallbacks] parseCSV fallback installed');
    }

    // showNotification fallback
    if (typeof showNotification !== 'function') {
      window.showNotification = function(message, type) {
        console.log('[showNotification]', type || 'info', message);
        try {
          const id = 'fallback-toast';
          let toast = document.getElementById(id);
          if (!toast) {
            toast = document.createElement('div');
            toast.id = id;
            toast.style.position = 'fixed';
            toast.style.right = '16px';
            toast.style.top = '16px';
            toast.style.zIndex = 99999;
            toast.style.maxWidth = '320px';
            document.body.appendChild(toast);
          }
          const item = document.createElement('div');
          item.textContent = message;
          item.style.margin = '6px';
          item.style.padding = '8px 12px';
          item.style.borderRadius = '6px';
          item.style.color = '#fff';
          item.style.fontSize = '13px';
          item.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
          if (type === 'success') item.style.background = '#28a745';
          else if (type === 'error') item.style.background = '#dc3545';
          else if (type === 'warning') { item.style.background = '#ffc107'; item.style.color = '#000'; }
          else item.style.background = '#17a2b8';
          toast.appendChild(item);
          setTimeout(()=>{ try{ item.remove(); }catch(e){} }, 4000);
        } catch(e){}
      };
      console.info('[fallbacks] showNotification fallback installed');
    }

    // LocalStorage wrappers
    if (typeof loadFromLocalStorage !== 'function') {
      window.loadFromLocalStorage = function(key) {
        try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : null; } catch(e) { return null; }
      };
      console.info('[fallbacks] loadFromLocalStorage fallback installed');
    }
    if (typeof saveToLocalStorage !== 'function') {
      window.saveToLocalStorage = function(key, value) {
        try { localStorage.setItem(key, JSON.stringify(value)); return true; } catch(e) { return false; }
      };
      console.info('[fallbacks] saveToLocalStorage fallback installed');
    }

    // arrayToCSV & downloadFile
    if (typeof arrayToCSV !== 'function') {
      window.arrayToCSV = function(arr) {
        if (!Array.isArray(arr) || arr.length===0) return '';
        const headers = Object.keys(arr[0]);
        const lines = [headers.join(',')];
        arr.forEach(row=>{
          const cols = headers.map(h=>{
            let v = row[h] === null || row[h] === undefined ? '' : String(row[h]);
            if (v.includes('"')) v = v.replace(/"/g,'""');
            if (/[,"\n]/.test(v)) v = `"${v}"`;
            return v;
          });
          lines.push(cols.join(','));
        });
        return lines.join('\r\n');
      };
      console.info('[fallbacks] arrayToCSV fallback installed');
    }
    if (typeof downloadFile !== 'function') {
      window.downloadFile = function(content, filename, mime='text/plain') {
        try {
          const blob = new Blob([content], { type: mime });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = filename || 'download';
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        } catch(e){ console.error('[fallbacks] downloadFile error', e); }
      };
      console.info('[fallbacks] downloadFile fallback installed');
    }

    // safe groupBy/aggregate fallbacks assigned to internal names to avoid collisions with DOM ids
    if (typeof window.__groupBy !== 'function') {
      window.__groupBy = function(arr, key) {
        const result = {}; if (!Array.isArray(arr)) return result;
        for (const item of arr) {
          const k = (item && Object.prototype.hasOwnProperty.call(item, key)) ? item[key] : '__undefined__';
          const sk = (k === null || k === undefined) ? '__null__' : String(k);
          if (!result[sk]) result[sk] = [];
          result[sk].push(item);
        }
        console.info('[fallbacks] __groupBy fallback installed');
        return result;
      };
    }
    if (typeof window.__aggregate !== 'function') {
      window.__aggregate = function(items, xCol, yCol, aggType) {
        aggType = (aggType||'sum').toLowerCase();
        const buckets = {};
        if (!Array.isArray(items)) return {};
        for (const row of items) {
          const x = row && Object.prototype.hasOwnProperty.call(row, xCol) ? row[xCol] : '__undefined__';
          const xv = (x === null || x === undefined) ? '' : String(x);
          let y = row && Object.prototype.hasOwnProperty.call(row, yCol) ? row[yCol] : null;
          const yNum = (y===null||y===undefined||y==='') ? NaN : Number(String(y).replace(/[^0-9\.\-eE]/g,''));
          if (!buckets[xv]) buckets[xv] = { nums: [], raw: [] };
          if (!isNaN(yNum)) buckets[xv].nums.push(yNum);
          buckets[xv].raw.push(y);
        }
        const out = {};
        for (const [k, v] of Object.entries(buckets)) {
          const nums = v.nums;
          if (aggType === 'count') out[k] = v.raw.length;
          else if (aggType === 'avg') out[k] = nums.length ? nums.reduce((a,b)=>a+b,0)/nums.length : 0;
          else if (aggType === 'max') out[k] = nums.length ? Math.max(...nums) : 0;
          else if (aggType === 'min') out[k] = nums.length ? Math.min(...nums) : 0;
          else out[k] = nums.length ? nums.reduce((a,b)=>a+b,0) : 0;
        }
        console.info('[fallbacks] __aggregate fallback installed (aggType=' + aggType + ')');
        return out;
      };
    }
  })();
  </script>

  <!-- Ensure Chart loader: will dynamically load Chart.js if not available -->
  <script>
  function ensureChart(callback) {
    if (typeof Chart !== 'undefined') return callback();
    const urls = [
      'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js',
      'https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js',
      'https://unpkg.com/chart.js@4.4.0/dist/chart.umd.min.js'
    ];
    let i=0;
    function tryLoad() {
      if (i>=urls.length) {
        const msg = 'No se pudo cargar Chart.js desde CDN. Comprueba Network o a침ade Chart.js localmente.';
        console.error('[ensureChart]', msg);
        if (typeof showNotification === 'function') showNotification(msg, 'error');
        return;
      }
      const src = urls[i++];
      console.debug('[ensureChart] intentando cargar', src);
      const s = document.createElement('script');
      s.src = src; s.async = true;
      s.onload = function(){ console.debug('[ensureChart] cargado', src); setTimeout(()=>callback(),10); };
      s.onerror = function(){ console.warn('[ensureChart] fallo cargando', src); s.remove(); tryLoad(); };
      document.head.appendChild(s);
    }
    tryLoad();
  }
  </script>

  <script>
    // State
    let currentData = [];
    let currentChart = null;
    let processedData = [];
    const STORAGE_KEY = 'dataviz-module-01';

    // Load / parse
    function loadCSV(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        try { currentData = (typeof parseCSV === 'function') ? parseCSV(text) : []; }
        catch(err){ currentData = []; console.error('parseCSV error', err); }
        displayData();
        populateColumnSelects();
        if (typeof showNotification === 'function') showNotification('CSV cargado correctamente', 'success');
      };
      reader.readAsText(file);
    }
    function parseManualCSV() {
      const text = document.getElementById('csvTextInput').value.trim();
      if (!text) { if (typeof showNotification === 'function') showNotification('Por favor ingresa datos CSV','error'); return; }
      try { currentData = (typeof parseCSV === 'function') ? parseCSV(text) : []; }
      catch(err){ currentData = []; console.error('parseCSV error', err); }
      displayData(); populateColumnSelects();
      if (typeof showNotification === 'function') showNotification('Datos cargados correctamente','success');
    }

    function displayData() {
      if (currentData.length === 0) return;
      const preview = document.getElementById('dataPreview');
      const table = document.getElementById('dataTable');
      const rowCount = document.getElementById('rowCount');
      preview.classList.remove('hidden');
      rowCount.textContent = currentData.length;
      const headers = Object.keys(currentData[0]);
      let html = '<thead><tr>';
      headers.forEach(h=> html += `<th>${h}</th>`);
      html += '</tr></thead><tbody>';
      currentData.slice(0,10).forEach(row=>{
        html += '<tr>';
        headers.forEach(h=> html += `<td>${row[h]}</td>`);
        html += '</tr>';
      });
      if (currentData.length>10) html += `<tr><td colspan="${headers.length}" style="text-align:center;font-style:italic">... y ${currentData.length-10} filas m치s</td></tr>`;
      html += '</tbody>';
      table.innerHTML = html;
    }

    function populateColumnSelects() {
      if (currentData.length === 0) return;
      const headers = Object.keys(currentData[0]);
      const xAxis = document.getElementById('xAxis');
      const yAxis = document.getElementById('yAxis');
      const groupBy = document.getElementById('groupBy');
      [xAxis,yAxis,groupBy].forEach(select=>{
        const current = select.value;
        select.innerHTML = select.id === 'groupBy' ? '<option value="">Sin agrupaci칩n</option>' : '<option value="">Selecciona columna...</option>';
        headers.forEach(h=>{
          const o = document.createElement('option'); o.value = h; o.textContent = h; select.appendChild(o);
        });
        if (current) select.value = current;
      });
    }

    // renderChart uses safe fallbacks: prefer repo functions, otherwise internal __aggregate/__groupBy
    function renderChart() {
      const xCol = document.getElementById('xAxis').value;
      const yCol = document.getElementById('yAxis').value;
      const chartType = document.getElementById('chartType').value;
      const groupByCol = document.getElementById('groupBy').value;
      const aggType = document.getElementById('aggregation').value;
      const title = document.getElementById('chartTitle').value || 'Gr치fico de Datos';

      if (!xCol || !yCol) { if (typeof showNotification === 'function') showNotification('Selecciona columnas para X e Y','error'); return; }
      if (currentData.length === 0) { if (typeof showNotification === 'function') showNotification('Primero carga un CSV','error'); return; }

      const groupByFn = (typeof window.groupBy === 'function') ? window.groupBy : (typeof window.__groupBy === 'function' ? window.__groupBy : null);
      const aggregateFn = (typeof window.aggregate === 'function') ? window.aggregate : (typeof window.__aggregate === 'function' ? window.__aggregate : null);

      if (!aggregateFn) {
        console.error('aggregate function not available'); if (typeof showNotification === 'function') showNotification('Funci칩n aggregate no disponible','error'); return;
      }

      let chartData;
      if (groupByCol && groupByFn) {
        const grouped = groupByFn(currentData, groupByCol);
        const datasets = [];
        for (const [group, items] of Object.entries(grouped)) {
          const aggregated = aggregateFn(items, xCol, yCol, aggType);
          datasets.push({ label: group, data: Object.values(aggregated), backgroundColor:`hsla(${Math.random()*360},70%,60%,0.8)`, borderColor:`hsla(${Math.random()*360},70%,50%,1)`, borderWidth:2 });
        }
        chartData = { labels: Object.keys(aggregateFn(currentData, xCol, yCol, aggType)), datasets: datasets };
      } else {
        const aggregated = aggregateFn(currentData, xCol, yCol, aggType);
        processedData = Object.entries(aggregated).map(([k,v])=> ({ [xCol]: k, [yCol]: v }));
        if (chartType === 'scatter') {
          const points = processedData.map(r=>{
            const xNum = Number(String(r[xCol]).replace(/[^0-9\.\-]+/g,'')); const yNum = Number(String(r[yCol]).replace(/[^0-9\.\-]+/g,'')) || 0;
            return { x: isNaN(xNum)?null:xNum, y: isNaN(yNum)?null:yNum };
          }).filter(p=>p.x!==null && p.y!==null);
          if (points.length===0) { if (typeof showNotification === 'function') showNotification('Scatter requiere valores num칠ricos en X','error'); return; }
          chartData = { datasets: [{ label: yCol, data: points, backgroundColor:'rgba(102,126,234,0.8)', borderColor:'rgba(102,126,234,1)', borderWidth:2 }] };
        } else {
          chartData = { labels: Object.keys(aggregated), datasets: [{ label: yCol, data: Object.values(aggregated), backgroundColor:'rgba(102,126,234,0.8)', borderColor:'rgba(102,126,234,1)', borderWidth:2 }] };
        }
      }

      if (currentChart) { currentChart.destroy(); currentChart = null; }

      const ctx = document.getElementById('myChart').getContext('2d');
      const cfg = {
        type: chartType === 'scatter' ? 'scatter' : chartType,
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { title:{ display:true, text:title, font:{ size:18 } }, legend:{ display:true } },
          scales: chartType !== 'pie' && chartType !== 'doughnut' ? { y: { beginAtZero: true } } : {}
        }
      };

      function createChartNow(){
        try {
          currentChart = new Chart(ctx, cfg);
          if (typeof showNotification === 'function') showNotification('Gr치fico generado correctamente','success');
        } catch(err) {
          console.error('Error creando chart (despu칠s de carga):', err);
          if (typeof showNotification === 'function') showNotification('Error al generar el gr치fico (ver consola)','error');
        }
      }

      if (typeof Chart !== 'undefined') createChartNow();
      else ensureChart(createChartNow);
    }

    function clearChart() { if (currentChart) { currentChart.destroy(); currentChart=null; if (typeof showNotification === 'function') showNotification('Gr치fico limpiado','info'); } }

    function downloadChart() {
      if (!currentChart) { if (typeof showNotification === 'function') showNotification('Primero genera un gr치fico','error'); return; }
      const canvas = document.getElementById('myChart');
      canvas.toBlob(blob=>{
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `modulo-01-grafico-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
        a.click(); URL.revokeObjectURL(url);
        if (typeof showNotification === 'function') showNotification('Gr치fico descargado','success');
      });
    }

    function downloadProcessedData() {
      if (processedData.length===0 && currentData.length===0) { if (typeof showNotification === 'function') showNotification('No hay datos para descargar','error'); return; }
      const dataToDownload = processedData.length>0 ? processedData : currentData;
      const csv = arrayToCSV(dataToDownload);
      downloadFile(csv, `modulo-01-datos-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`, 'text/csv');
      if (typeof showNotification === 'function') showNotification('Datos descargados','success');
    }

    // minimal quiz / storage helpers
    function updateSavedDataInfo(){ const results = loadFromLocalStorage(STORAGE_KEY); const content = document.getElementById('savedDataContent'); if (results) content.innerHTML = `<p><strong>칔ltima evaluaci칩n:</strong> ${new Date(results.date).toLocaleString('es-ES')}</p><p><strong>Puntuaci칩n:</strong> ${results.score}%</p><p><strong>M칩dulo:</strong> ${results.module}</p>`; else content.textContent = 'No hay datos guardados a칰n.'; }

    window.addEventListener('load', ()=>{
      console.log('Verificando helpers:', typeof parseCSV, typeof aggregate, typeof showNotification);
      if (typeof parseCSV !== 'function' || (typeof aggregate !== 'function' && typeof window.__aggregate !== 'function')) {
        if (typeof showNotification === 'function') showNotification('Advertencia: helpers no cargados (utils.js). Comprueba la consola y la red.','error');
        else console.warn('Advertencia: helpers no cargados (utils.js). Comprueba la consola y la red.');
      }
      updateSavedDataInfo();
    });
  </script>

  <!-- HOTFIX2: robust file input + drag&drop + delimiter-tolerant CSV parser (no auto-open) -->
  <script>
  (function(){
    let fi = document.getElementById('fileInput');
    if (!fi) {
      fi = document.createElement('input'); fi.type='file'; fi.id='fileInput'; fi.accept='.csv,text/csv';
      document.body.appendChild(fi);
    }
    const drop = document.querySelector('.file-upload-area');
    if (drop) {
      if (!drop.querySelector('#fileInput')) drop.appendChild(fi);
      drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.classList && drop.classList.add('dragover'); });
      drop.addEventListener('dragleave', e=>{ e.preventDefault(); drop.classList && drop.classList.remove('dragover'); });
      drop.addEventListener('drop', e=>{ e.preventDefault(); drop.classList && drop.classList.remove('dragover'); const files = e.dataTransfer && e.dataTransfer.files; if (files && files.length) handleFiles(files); });
    } else {
      fi.style.position='fixed'; fi.style.right='20px'; fi.style.top='80px';
    }

    function handleFiles(files){ if (!files || files.length===0) return; const file = files[0]; readFile(file); }
    function autoParseCSV(text){ if (!text) return []; const sample = text.slice(0,2000); const counts = { ',': (sample.match(/,/g)||[]).length, ';': (sample.match(/;/g)||[]).length, '\t': (sample.match(/\t/g)||[]).length }; let delim=','; if (counts[';']>counts[','] && counts[';']>=counts['\t']) delim=';'; else if (counts['\t']>counts[','] && counts['\t']>=counts[';']) delim='\t'; const lines = String(text).trim().split(/\r?\n/).filter(l=>l.trim().length>0); if (lines.length===0) return []; const headers = lines.shift().split(delim).map(h=>h.trim()); return lines.map(l=>{ const cols=l.split(delim); const obj={}; for (let i=0;i<headers.length;i++) obj[headers[i]]=(cols[i]||'').trim(); return obj; }); }
    function readFile(file){ if (!file) return; if (typeof FileReader==='undefined'){ console.error('[HOTFIX2] FileReader not supported'); return; } const r=new FileReader(); r.onload=function(e){ const text=e.target.result; const parseFn = (typeof parseCSV==='function') ? parseCSV : autoParseCSV; let data; try{ data = parseFn(text); }catch(err){ console.error('[HOTFIX2] parse error',err); if (typeof showNotification==='function') showNotification('Error parsing CSV','error'); return; } window.currentData = data; if (typeof displayData==='function'){ try{ displayData(); }catch(e){ console.error('[HOTFIX2] displayData error',e); } } if (typeof populateColumnSelects==='function'){ try{ populateColumnSelects(); }catch(e){ console.error('[HOTFIX2] populateColumnSelects error',e); } } if (typeof showNotification==='function') showNotification('CSV cargado correctamente','success'); }; r.onerror=function(err){ console.error('[HOTFIX2] FileReader error',err); if (typeof showNotification==='function') showNotification('Error leyendo archivo','error'); }; r.readAsText(file,'UTF-8'); }
    fi.addEventListener('change', e => handleFiles(e.target.files));
    window.__hotfix2 = { handleFiles, autoParseCSV };
  })();
  </script>

</body>
</html>
